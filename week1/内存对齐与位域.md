# 内存对齐与位域

## 内存对齐

> 对齐是编译器所执行的操作

对于内置类型，有以下对齐要求

1. 占两个字节的short类型的首地址必须为偶数
2. 占四个字节的int,float类型的首地址必须为4的倍数
3. 占8个字节的long,double类型的首地址必须为8的倍数
4. 32位系统的指针（4字节）首地址为4的倍数，64位系统（8字节）必须为8的倍数
5. 只占一个字节的char类型不作对齐要求

> 内存对齐使得从内存中存取数据的效率提升，可以在一个指令周期内取得数据

## 普通变量的补齐

普通变量指的是不在struct中的变量

```c
//以下代码写在全局作用域中
int a;
char ch;
double b;
```

若不考虑变量补齐，这三个变量一共占据$4+1+8=13$字节的内存

而这是不对的，如上所述，int类型的首地址必须为4的倍数，那么如果这三个变量在内存中连续存放，double的首地址就不可能在8倍数的位置处，违反了上述的对齐规则

实际情况是不能确定的
```c
int a;
char pad1[?];   //这里两处补齐的数量不定的原因是，编译器不保证将a和ch连续存放，因为只需要满足double的对齐要求即可，char没有对齐要求
char ch;        //两处补齐的总数量同样是不定的，如果a的首地址恰好为8的倍数，则补白数量为7
char pad2[?];   //如果a的首地址是4的倍数，而不是8的倍数，则只需要3个补白
double b;
```

## 结构体变量的补齐

结构体成员变量和实例变量除去上述的对齐要求外，还遵循如下额外要求

1. 结构体**实例变量**的首地址就是结构体中声明的第一个变量的首地址（该要求在C++中不成立）
2. 结构体**实例变量**的首地址对齐规则与结构体中**占用字节数最多的成员变量**所要求的对齐规则相同
3. 结构体末尾补齐规则：定义跨步地址(stride address)为结构体实例变量内存空间后**第一个**满足结构体实例变量对齐规则的地址，结构体实例变量尾部补齐到该地址之前
4. 嵌套结构体的首地址和尾部补齐要求与普通结构体相同

```c
//例1
struct foo{
    struct foo* p;
    char ch;
    double d;
};
```
按照普通的对齐要求，上述结构体与如下结构体等价
```c
struct foo{
    struct foo* p;
    char ch;
    char pad[7];    //注:不一定所有的补白都在ch之后，这么写是为了简化
    double d;
};
```

```c
//例2
struct foo{
    char ch;
    struct foo* p;
    double d;
};
```
如果只是遵循普通的对齐规则，ch的首地址可以在任意位置，然而，由于要求1和2，结构体实例变量必须为8对齐，因此ch的首地址也必须为8对齐
```c
struct foo{
    char ch;
    char pad[7];
    struct foo* p;
    double d;
};
```

```c
//例3
struct foo{
    struct foo* p;
    double d;
    char ch;
};
```
按照普通的对齐规则和要求1,2，$sizeof(foo)$应为17，然而由于要求3，结构体实例变量尾部必须为8对齐
```c
struct foo{
    struct foo* p;
    double d;
    char ch;
    char pad[7];
};
```

> 综上，合理安排结构体中成员变量的顺序，可以减少内存消耗

## 位域

C/C++提供位域来对位进行操作

当需要定义0/1标志变量时，使用int类型需要4个字节内存，而使用位域只需要1个bit

> 位域实际上是对其所依附的基本数据类型的拆分

```c
struct foo{
    //基本规则为   依附数据类型 位域名 : bit的数量;
    int a : 1;  //a占1bit
    int b : 2;  //b占2bits
    int c : 3;  //c占3bits
    int d : 5;  //d占5bits
    //虽然所有位域一共只占11bits,但还是会分配一个int（也就是4个字节）的空间，即sizeof(foo) == 4
};
int main(){
    foo f;
    f.a = 0;    //位域的访问与普通成员变量完全相同
    f.b = 8;    //注意赋值时不要超过范围，超过后只保留低位
}
```
位域成员为符号还是无符号由其依附的基本数据类型决定，若基本数据类型为unsigned，则位域成员的值也按unsigned处理

